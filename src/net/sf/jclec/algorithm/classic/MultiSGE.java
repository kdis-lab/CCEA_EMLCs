package net.sf.jclec.algorithm.classic;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.IIndividual;

import net.sf.jclec.selector.WorsesSelector;
import net.sf.jclec.selector.BettersSelector;

/**
 * <strong><u>S</u></strong>imple  <strong><u>G</u></strong>enerational and 
 * <strong><u>E</u></strong>litist algorithm. Like a generational algorithm, 
 * but ensures that best individual passes to the next generation any time. 
 * 
 * It is implemented to allow multiple subpopulations.
 * 
 * @author Sebastian Ventura
 * @author Jose M. Moyano
 */

public class MultiSGE extends MultiSG 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	private static final long serialVersionUID = -2649346083463795286L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------- Internal variables
	/////////////////////////////////////////////////////////////////

	/** Betters selector. Used in update phase */
	BettersSelector bettersSelector = new BettersSelector(this);
	
	/** Worses selector. Used in update phase */
	WorsesSelector worsesSelector = new WorsesSelector(this);
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty (default) constructor
	 */
	public MultiSGE() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Like SG, but ensuring that current best individual pass to the
	 * new population.
	 */
	@Override
	protected void doUpdate() 
	{
		IIndividual bestb=null, bestc=null;
		for(int p=0; p<numSubpop; p++) {
			bestb = bettersSelector.select(bset.get(p), 1).get(0);
			bestc = bettersSelector.select(cset.get(p), 1).get(0);
			
			// If best individual in b set (bestb) is better that best 
			// individual in c set (bestc), remove worst individual in 
			// c set (worstc) and add bestb to c set
			if (evaluator.getComparator().compare(bestb.getFitness(), bestc.getFitness()) == 1) {
				IIndividual worstc = worsesSelector.select(cset.get(p), 1).get(0);
				cset.get(p).remove(worstc);
				cset.get(p).add(bestb);
			}
			bset.set(p, new ArrayList<>(cset.get(p)));
			//Order individuals
			bset.set(p, bettersSelector.select(bset.get(p), bset.get(p).size()));
			
			pset.get(p).clear();
			rset.get(p).clear();
			cset.get(p).clear();
		}
	}
}
