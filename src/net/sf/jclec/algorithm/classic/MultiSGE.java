package net.sf.jclec.algorithm.classic;

import net.sf.jclec.IIndividual;

import net.sf.jclec.selector.WorsesSelector;
import net.sf.jclec.selector.BettersSelector;

/**
 * <strong><u>S</u></strong>imple  <strong><u>G</u></strong>enerational and 
 * <strong><u>E</u></strong>litist algorithm. Like a generational algorithm, 
 * but ensures that best individual passes to the next generation any time. 
 * 
 * @author Sebastian Ventura
 * @author Jose M. Moyano
 */

public class MultiSGE extends MultiSG 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -2649346083463795286L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------- Internal variables
	/////////////////////////////////////////////////////////////////

	/** Betters selector. Used in update phase */
	
	BettersSelector bettersSelector = new BettersSelector(this);
	
	/** Worses selector. Used in update phase */

	WorsesSelector worsesSelector = new WorsesSelector(this);
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty (default) constructor
	 */
	
	public MultiSGE() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Like SG, but ensuring that current best individual pass to the
	 * new population.
	 */
	
	@Override
	protected void doUpdate() 
	{
		IIndividual bestb=null, bestc=null;
		for(int i=0; i<numSubpop; i++) {
			bestb = bettersSelector.select(bset.get(i), 1).get(0);
			bestc = bettersSelector.select(cset.get(i), 1).get(0);
			
			// If best individual in b set (bestb) is better that best 
			// individual in c set (bestc), remove worst individual in 
			// c set (worstc) and add bestb to c set
			if (evaluator.getComparator().compare(bestb.getFitness(), bestc.getFitness()) == 1) {
				IIndividual worstc = worsesSelector.select(cset.get(i), 1).get(0);
				cset.get(i).remove(worstc);
				cset.get(i).add(bestb);
			}
		}
				
		// Sets new bset
		bset = cset;
		// Clear pset, rset & cset
		pset = null;
		rset = null;
		cset = null;	
	}
}
